# 时间复杂度分析

***

## 算法的评估
在竞赛中，一般算机一秒能运行5 x 10^8次汁算，如果题目給出的时间限制カ1s,那么你选择的算法执行的汁算次数最多应该在10^8量级オ有可能解决这个题目。
* O(n)的算法能解决的数据范围在n < 10^8。
* O(n*log2(n))的算法能解决的数据范围在n <= 10^6。
* O(n*sqrt(n) )的算法能解决的数据范围在n < 10^5。
* O(n^2)的算法能解决的数据范围在n<5000。
* O(n^3)的算法能解决的数据范围在n <300。
* O(2^n)的算法能解决的数据范围在n < 25。
*  O(n!)的算法能解决的数据范围在n < 11。
>以上范围仅供参考，实际中还要考虑每种算法的常数。

### O(1)
计算时间是一个常数, 和问题的规模n无关. 例如, 用公示计算时, 一次计算的复杂度就是O(1);哈希算法计算储存位置;在矩阵A[i][j]找对应元素.
### O(log2(n))
计算时间是对数, 通常是以2为低的对数, 每一步计算后, 问题规模减少一倍.例如在一个长度为n的有序数列中查找某个数, 用折半法; 分治法
### O(n)
计算时间随规模n线性增长. 在很多情况下, 这是一个算法可能达到的最优复杂度, 因为输入n个数, 程序一般需要处理所有的数, 即n.
### O(n*log2(n))) 
这常常是算法能达到的最优复杂度. 例如分治法-〉 快速排序, 归并排序
### O(2^n)
一般对应集合问题, 例如一个集合中有n个数, 要求输出它的所有子集.
### O(n!)
输出所有的全排列.

上述可分为两种, 一种是多项式复杂度,称它们为高效算法; 如果是指数复杂度, 则称它们低效算法. 