## 2021省赛 C++ B组 试题A 空间

#### 题目描述
小蓝准备用256MB的内存空间开一个数组，数组的每个元素都是32 位二进制整数。
如果不考虑程序占用的空间和维护内存需要的辅助空间，请问256MB 的空间可以存储多少个32 位二进制整数？

#### 题目标签
* 填空题
* 基础知识

#### 解题思路
1MB= 1024KB 1KB= 1024B 1B= 8b

#### 答案
268435456

```CPP
#include <iostream>
using namespace std;

int main() {
  cout << 1024 * 1024 * 256 << endl;
  return 0;
}
```


## 2021国赛 C++ B组 试题A 带宽
#### 题目描述
小蓝家的网络带宽是 200 Mbps，请问，使用小蓝家的网络理论上每秒钟最多可以从网上下载多少 MB 的内容。

#### 题目标签
* 填空题
* 基础知识

#### 解题思路
Mbps / 8 = Mb/s

#### 答案
25


## 2019省赛 C++ A组 试题B 数列求值

#### 题目描述
给定数列 1, 1, 1, 3, 5, 9, 17, …，从第 4 项开始，每项都是前 3 项的和。求
第 20190324 项的最后 4 位数字。

#### 题目标签
* 选择题

#### 答案
4659

```CPP
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
  int a = 1, b = 1, c = 1, temp;
  for (int i = 4; i <= 20190324; ++i) {
    temp = (a + b + c) % 10000;
    a = b;
    b = c;
    c = temp;
  }
  cout << c;
  return 0;
}
```

## 2016省赛 C++ B组 试题A 煤球数量

#### 题目描述
    有一堆煤球，堆成三角棱锥形。具体：
    第一层放1个，
    第二层3个（排列成三角形），
    第三层6个（排列成三角形），
    第四层10个（排列成三角形），
    ...
    如果一共有100层，共有多少个煤球？

#### 题目标签
* 填空题
* 堆叠问题

#### 解题思路
* 第一层1个球， 第二层1 + 2个球， 第三层1 + 2 + 3个球，可知第n层为 1 + 2 + 3 + ... + n个球。
* 数学

#### 答案
171700

```CPP
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
  int floor = 0, cnt = 0;
  for (int i = 1; i <= 100; ++i) {
    floor += i;
    cnt += floor;
  }
  cout << cnt;
  return 0;
}
```

## 2016省赛 C++ A组 试题B 生日蜡烛

#### 题目描述
某君从某年开始每年都举办一次生日party，并且每次都要吹熄与年龄相同根数的蜡烛。 现在算起来，他一共吹熄了236根蜡烛。
请问，他从多少岁开始过生日party的？

#### 题目标签
* 填空题

#### 答案
26

```CPP
#include <iostream>
using namespace std;

int main() {
  for (int i = 0; i <= 100; ++i) {
    int sum = 0;
    for (int j = i; j <= 100; ++j) {
      sum += j;
      if (sum == 236) {
        cout << i << endl;
        return 0;
      }
    }
  }
  return -1;
}
```

## 2012省赛 C++ 试题A 微生物增殖

#### 题目描述
假设有两种微生物 X 和 Y，X出生后每隔3分钟分裂一次（数目加倍），Y出生后每隔2分钟分裂一次（数目加倍）。一个新出生的X，半分钟之后吃掉1个Y，并且，从此开始，每隔1分钟吃1个Y。现在已知有新出生的 X=10, Y=89，求60分钟后Y的数目。如果X=10，Y=90呢？本题的要求就是写出这两种初始条件下，60分钟后Y的数目。

#### 题目标签
* 填空题

#### 解题思路
* 先分别列举前几秒的情况，找到规律。
* 可以发现新Y半分钟一吃的问题很容易解决。只需要每分钟吃掉X个Y即可。

#### 答案
0 94371840
```CPP
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
//long long x = 10, y = 89;
  long long x = 10, y = 90; 
  for (int i = 1; i <= 60; ++i) {
    y -= x;
    if (i % 2 == 0) y *= 2;
    if (i % 3 == 0) x *= 2;
    if (y < 0) y = 0;
    cout << x << " " << y << endl;
  }
  return 0;
}
```

## 2012省赛 C++ 试题B 古堡算式

#### 题目描述
 福尔摩斯到某古堡探险，看到门上写着一个奇怪的算式：
    ABCDE * ? = EDCBA

    他对华生说：“ABCDE应该代表不同的数字，问号也代表某个数字！”

    华生：“我猜也是！”

    于是，两人沉默了好久，还是没有算出合适的结果来。

    请你利用计算机的优势，找到破解的答案。

    把 ABCDE 所代表的数字写出来。

#### 题目标签
* 填空题

#### 答案
21978
```CPP
#include <iostream>
using namespace std;
#define F(i) for (int i = 1; i < 10; ++i)

int main() {
  F(a) F(b) F(c) F(d) F(e) {
    for (int i = 2; i < 10; ++i) {
      if ((a * 10000 + b * 1000 + c * 100 + d * 10 + e) * i ==
          (e * 10000 + d * 1000 + c * 100 + b * 10 + a)) {
        cout << a << b << c << d << e << endl;
      }
    }
  }
  return 0;
}
```

## 2019省赛 C++ B组 试题D 数的分解

#### 题目描述
把 2019 分解成 3 个各不相同的正整数之和，
并且要求每个正整数都不包含数字2和4，一共有多少种不同的分解方法？
注意交换3个整数的顺序被视为同一种方法。

#### 题目标签
* 填空题

#### 解题思路
满足以下4个条件:
1. 要求分解成三个整数
2. 三个整数各不相同，不可以出现重复
3. 三个数的顺序调换加和得到2019被视作为一种方法
4. 被分解的三个数中 2，4 不可以同时出现

#### 答案
40785
```CPP
#include <iostream>
#include <algorithm>
using namespace std;

bool judge(int num) {
  while (num) {
    if (num % 10 == 2 || num % 10 == 4) return false;
    num /= 10;
  }
  return true;
}

int main() {
  int i = 0, j = 0, k = 0, cnt = 0;
  for (int i = 1; i < 2019; ++i) 
    for (int j = 1; j < 2019; ++j) {
      k = 2019 - i - j;
      if (judge(i) && judge(j) && judge(k)) {
        if (i < j && j < k) ++cnt;
      }
    }
  cout << cnt << endl;
  return 0;
}
```

## 2018省赛 C++ B组 试题D 测试数据

#### 题目描述
x星球的居民脾气不太好，但好在他们生气的时候唯一的异常举动是：摔手机。
各大厂商也就纷纷推出各种耐摔型手机。x星球的质监局规定了手机必须经过耐摔测试，并且评定出一个耐摔指数来，之后才允许上市流通。

x星球有很多高耸入云的高塔，刚好可以用来做耐摔测试。塔的每一层高度都是一样的，与地球上稍有不同的是，他们的第一层不是地面，而是相当于我们的2楼。

如果手机从第7层扔下去没摔坏，但第8层摔坏了，则手机耐摔指数=7。
特别地，如果手机从第1层扔下去就坏了，则耐摔指数=0。
如果到了塔的最高层第n层扔没摔坏，则耐摔指数=n

为了减少测试次数，从每个厂家抽样3部手机参加测试。

某次测试的塔高为1000层，如果我们总是采用最佳策略，在最坏的运气下最多需要测试多少次才能确定手机的耐摔指数呢？

请填写这个最多测试次数。

注意：需要填写的是一个整数，不要填写任何多余内容。

#### 题目标签
* 选择题
* 动态规划 DP

#### 解题思路
令dp[i][j]为第i层手机剩余j个时的最优测试次数，设第一摔为k，每一层都可为第一摔，则第一摔只有两种情况：
1. 碎

    如果碎了，那么此层之上不再考虑，只需考虑此层之下，将楼层数和剩余手机数都减1，即dp[k - 1][j - 1]。

2. 不碎

    如果没有碎，那么此层之下不再考虑，只需考虑此层之上，将楼层数加1，即dp[i- k][j]。

综上，我们从第k层开始摔，最坏情况下需要max(dp[k - 1][j - 1], dp[i - k][j]) + 1 次测试。
而k有多种选择，因此最好的结果为dp[i][j] = min(max(dp[k - 1][j - 1]) + 1)。

存在最优解，故采用最优解策略，求子问题的最小值即可，而碎或未碎会存在最坏情况，故求子决策的最大值即可。

> 思路来自CSDN [weixin_48851802](https://blog.csdn.net/weixin_48851802/article/details/107097381) 

#### 答案
19
```CPP
#include <algorithm>
#include <cmath>
#include <iostream>
using namespace std;

int dp[1001][4];

int main() {
  for (int n = 1; n <= 3; ++n) {
    for (int i = 1; i <= 1000; ++i) {
      dp[i][n] = dp[i - 1][n] + 1;
      for (int k = 1; k < i && n > 1; ++k)
        dp[i][n] = min(dp[i][n], max(dp[k - 1][n - 1], dp[i - k][n]) + 1);
    }
  }
  cout << dp[1000][3] << endl;
  return 0;
}
```
