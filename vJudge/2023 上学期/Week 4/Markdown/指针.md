## 指针是什么?
指针(pointer), C语言中的一个重要概念及其特点, 也是掌握C语言比较困难的部分, 指针也就是**内存地址**, **指针变量是用来存放内存地址的变量**.

指针描述了数据在内存中的位置, 标示了一个占据存储空间的实体, 在这一段空间起始位置的相对距离值. 在 C/C++语言中, 指针一般被认为是指针变量, 指针变量的内容存储的是其指向的对象的**首地址**, 指向的对象可以是变量（指针变量也是变量），数组，函数等占据存储空间的实体.
> 转载自[百度百科](https://baike.baidu.com/item/指针/2878304)

每一个变量都有一个内存位置, 每一个内存位置都定义了可使用 & 运算符访问的地址, 它表示了在内存中的一个地址.
#### 实例
```CPP
#include <stdio.h>
int main() {
  int i = 233;
  printf("变量i的地址为 %p\n", &i);
  return 0;
}
```
当以上代码被编译后执行时, 会产生下列结果.
```
变量i的地址为 0x30e094198
```


## 为什么要学习指针?
在C语言中, 指针的使用非常广泛, 因为使用指针往往非常高效. 而对于我们来说, 要能够读懂指针, 熟练的传递参数. 总的来说, 使用指针有以下好处:
*  快速高效, 节省内存. 指针为我们提供了一种简洁的方式访问数据.
*  共享方便. 指针可以在不同模块间共享数据.
*  实现动态规划. 指针可以很方便的动态规划数据储存.

## 如何使用指针?
### 声明并初始化指针
指针就是一个变量, 和变量的声明没太大区别. 格式为: 

**数据类型 * 指针名称**
```CPP
int *ptr;  //声明一个int类型的指针变量ptr.
char *ptr; //声明一个char类型的指针变量ptr.
int *ptr, *ptr2, *ptr3; //声明多个int类型的指针.
int *arr[10]; //声明一个指针数组, 该数组的每个元素都是一个指向int类型对象的指针.
int (*arr)[10]; //声明一个数组指针, 改指针指向一个int类型的一维数组.
```
指针的声明比普通变量的声明多了一个一元运算符 “ * ”. 运算符 “ * ” 是间接寻址或者间接引用运算符, 当它作用于指针时, 将访问指针所指向的对象.

声明一个指针变量并不会自动分配任何内存。在对指针进行间接访问之前，指针必须进行初始化: 或是使他指向现有的内存, 或者给他动态分配内存, 否则我们并不知道指针指向哪儿.
#### 实例
```CPP
#include <stdio.h>
int main() {
  int i = 233;
  printf("变量i的地址为 %p\n", &i);
  int *ptr = &i; // 初始化指针tpr
  printf("指针变量ptr指向的变量的地址为 %p\n", ptr);
  printf("指针变量ptr的地址为 %p", &ptr);
  return 0;
}
```
当以上代码被编译后执行时, 会产生下列结果.
```
变量i的地址为 0x30e094198
指针变量ptr指向的变量的地址为 0x30e094198
指针变量ptr的地址为 0x30e094190
```

### 未初始化和非法的指针 
如果一个指针没有被初始化, 那么程序就不知道它指向哪里. 它可能指向一个非法地址, 这时, 程序会报错, 在 Linux 上，错误类型是 Segmentation fault（core dumped）, 提醒我们段违例或内存错误. 它也可能指向一个合法地址, 实际上, 这种情况更严重, 你的程序或许能正常运行, 但是这个没有被初始化的指针所指向的那个位置的值将会被修改, 而你并无意去修改它.

### NULL指针
NULL 指针是一个特殊的指针变量, 表示不指向任何东西. 可以通过给一个指针赋一个零值(NULL)来生成一个 NULL 指针. 在C++11后, 可用更好的nullptr代替NULL指针.

### 指针的运算
C 指针的算术运算只限于两种形式:
* 指针(ptr) +/- 整数(i)

所得结果是个指针, 表示所指地址前进或后退i个操作位.

* 指针(ptr2) - 指针(ptr1)

只有当两个指针都指向同一个数组中的元素时, 才允许从一个指针减去另一个指针. 两个指针相减的结果的类型是 ptrdiff_t, 它是一种有符号整数类型. 减法运算的值是两个指针在内存中的距离.
#### 实例
```CPP
#include <stdio.h>
int main() {
  int a[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

  int *ptr = a;
  for (int i = 0; i < 10; ++i) printf("%d ", *(a + i));
  printf("\n");

  int *ptr2 = &a[8], *ptr1 = a + 2;
  printf(",ptr2 与 ptr1 相隔 %ld", ptr2 - ptr1);
  
  return 0;
}
```
当以上代码被编译后执行时, 会产生下列结果.
```
0 1 2 3 4 5 6 7 8 9 
ptr2 与 ptr1 相隔 6
```


## 指针与数组
在C语言中, 指针和数组这两个概念之间的联系非常密切. 在学习指针的概念后, 可以发现凡是由数组下标完成的操作皆可用指针来实现.
#### 实例
```CPP
#include <stdio.h>
int main() {
  int a[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  int *ptr = a;

  for (int i = 0; i < 10; ++i) printf("%d ", *(a + i));
  printf("\n以上是用指针完成的循环\n");

  for (int i = 0; i < 10; ++i) printf("%d ", a[i]);
  printf("\n以上是用数组下标完成的循环\n");


  return 0;
}
```
当以上代码被编译后执行时, 会产生下列结果.
```
0 1 2 3 4 5 6 7 8 9 
以上是用指针完成的循环
0 1 2 3 4 5 6 7 8 9 
以上是用数组下标完成的循环
```

## 指针与函数
在大多数程序设置语言中, 函数传递的方式通常有两种: 按值传递和按引用传递. 按值传递实参时, 程序为被调函数的形参分配新的内存, 将实参的复制到对应的形参变量中. 形参是实参的副本, 在被调函数中改变形参的值, 对主调函数中的实参没有任何影响. 而当按引用传递实参时, 主调函数则允许被调函数对实参变量的值进行修改.

**在C语言中所有的参数传递都是按值传递的!** 但是很多函数都要求具有这样一种功能:修改主调函数中某些变量的值, 或者说传递一个复杂数据. 对此,我们可以使用指针和间接寻址运算符*来模拟按引用传递, 或者使用&取地址模拟.
#### 实例

```CPP
#include <stdio.h>

void swap1(int *a, int *b) { int t = *a; *a = *b; *b = t; };
void swap2(int &a, int &b) { int t = a; a = b; b = t; };

int main() {
  int a = 1, b = 3, c = 2;
  swap1(&a, &c);
  swap2(a, b);
  printf("%d %d %d\n", a, b, c);

  int arr[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8 ,9};
  swap1(arr, arr + 1);
  swap2(arr[0], arr[1]);
  for (int i = 0; i < 10; ++i) printf("%d ", *(arr + i));
  return 0;
}

```
当以上代码被编译后执行时, 会产生下列结果.
```
3 2 1
0 1 2 3 4 5 6 7 8 9 
```

## 复杂指针说明
* int p; -- 这是一个普通的整型变量
* int *p; -- 首先从 p 处开始,先与*结合,所以说明 p 是一个指针, 然后再与 int 结合, 说明指针所指向的内容的类型为 int 型。所以 p 是一个返回整型数据的指针。
* int p[3] -- 首先从 p 处开始,先与[] 结合,说明 p 是一个数组, 然后与 int 结合, 说明数组里的元素是整型的, 所以 p 是一个由整型数据组成的数组。
* int *p[3]; -- 首先从 p 处开始, 先与 [] 结合, 因为其优先级比 * 高,所以 p 是一个数组, 然后再与 * 结合, 说明数组里的元素是指针类型, 然后再与 int 结合, 说明指针所指向的内容的类型是整型的, 所以 p 是一个由返回整型数据的指针所组成的数组。
* int (*p)[3]; -- 首先从 p 处开始, 先与 * 结合,说明 p 是一个指针然后再与 [] 结合(与"()"这步可以忽略,只是为了改变优先级), 说明指针所指向的内容是一个数组, 然后再与int 结合, 说明数组里的元素是整型的。所以 p 是一个指向由整型数据组成的数组的指针。
* int **p; -- 首先从 p 开始, 先与 * 结合, 说是 p 是一个指针, 然后再与 * 结合, 说明指针所指向的元素是指针, 然后再与 int 结合, 说明该指针所指向的元素是整型数据。由于二级指针以及更高级的指针极少用在复杂的类型中, 所以后面更复杂的类型我们就不考虑多级指针了, 最多只考虑一级指针。
* int p(int); -- 从 p 处起,先与 () 结合, 说明 p 是一个函数, 然后进入 () 里分析, 说明该函数有一个整型变量的参数, 然后再与外面的 int 结合, 说明函数的返回值是一个整型数据。
* int (*p)(int); -- 从 p 处开始, 先与指针结合, 说明 p 是一个指针, 然后与()结合, 说明指针指向的是一个函数, 然后再与()里的 int 结合, 说明函数有一个int 型的参数, 再与最外层的 int 结合, 说明函数的返回类型是整型, 所以 p 是一个指向有一个整型参数且返回类型为整型的函数的指针。
* int *(*p(int))[3]; -- 可以先跳过, 不看这个类型, 过于复杂从 p 开始,先与 () 结合, 说明 p 是一个函数, 然后进入 () 里面, 与 int 结合, 说明函数有一个整型变量参数, 然后再与外面的 * 结合, 说明函数返回的是一个指针, 然后到最外面一层, 先与[]结合, 说明返回的指针指向的是一个数组, 然后再与 * 结合, 说明数组里的元素是指针, 然后再与 int 结合, 说明指针指向的内容是整型数据。所以 p 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数。

**更多内容参考：[C 指针详解](https://www.runoob.com/w3cnote/c-pointer-detail.html)**

## 关于内存、 指针的学习视频

<iframe src="//player.bilibili.com/player.html?bvid=BV1ER4y157uA&cid=518035412&page=5&danmaku=0" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe>